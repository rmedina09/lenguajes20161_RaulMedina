# Calificaciones

## Practicas

### Practica 1

Buena practica, sigan así.

**Calificación: 10**

### Practica 2

Muy buena practica, vas muy bien.

**Calificación: 10**

### Practica 3

Tu implementación de haversine es erronea puesto que tu implementación
de total-distance es correcta pero regresas valores fuera de rango.

**Calificación: 10**

### Practica 4

Muy bien.

**Calificación: 10**

### Practica 5

Muy bien.

**Calificación: 0**

### Practica 6

Muy bien.

**Calificación: 0**

## Tareas

### Tarea 1
Problema I: Tu ejemplo no muestra claramente que no sea lineal usando stack,
aparte que estas teniendo scope dinamico al tomar el primer 'x'.
Tu solucion no resuelve mucho si tienes stacks por funcion en las cuales
posiblemente tienes que buscar hasta el fondo del stack.
Problema II: Muy bien.
Problema III: Bien

**Calificación: 9**

### Tarea 2

Problema 1: FAE es equivalente a calculo lambda en el cual se pueden definir
los conceptos de verdadero, falso y condicional por medio de funciones, y usando
el combinador Y se pueden obtener funciones recursivas anonimas por lo que FAE si es Turing Completo.

Problema 2: Bien, el ejemplo es algo rebuscado.

Problema 3: Si hay diferencia ejecutar la siguiente expresion:
(rinterp (cparse '{{fun {x} x} x})), con el interprete de Shriram nos
regresa un expresion closure, mientras que Doug es gloton de mas y nos 
regresa un error de que x no esta en el ambiente.

Problema 4: Sin respuesta.

**Calificación: 5**

### Tarea 3

**Calificación: 0**